/*
 * File:          OLED_display_avr8_lib.c
 *
 * Overview:      Library for Monochrome Graphic LCD or OLED module, 128 x 64 pixels.
 *                Customized for 8-bit AVR microcontroller devices.
 *                Character font tables are located in flash program memory to conserve
 *                MCU data RAM spce.
 *
 * Target MCU:    AVR 8-bit MCU family, e.g. ATmega32U4, ATmega328P, etc.
 *
 * Dependencies:  This module links with a low-level driver module supporting the LCD controller
 *                chip-set, which may be "LCD_KS0108_drv.c" (for KS0107/KS0108 chipset),
 *                LCD_ST7920_drv.c (for ST7920 chip), or OLED_SH1106_drv.c (for SH1106 chip).
 *
 * Originated:    2015 M.J. Bauer,  Last Revised: June 2024   [www.mjbauer.biz]
 */
#include "OLED_display_avr8_lib.h"

// These functions are not meant to be called directly from the application:
void   LCD_PutChar8(uint8 uc);
void   LCD_PutChar12(uint8 uc);
void   LCD_PutChar16(uint8 uc);


/*`````````````````````````````````````````````````````````````````````````````````````````````````
*   Font definition -- 5 x 8 pixels -- MONO-SPACED;  96 ASCII characters
*   Char cell: 5 x 8 pixels (8 bytes/char); each byte is a row of 5 pixels, left justified.
*
*   Format:  char bits = b7..b3,  blank bits = b2, b1 and b0;  b7 is LHS.
*            Lower-case descenders use the 8th byte.
*
*/
const uint8  font_table_mono_5x8[] PROGMEM =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // space
    0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x20, 0x00,   // !
    0x50, 0x50, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00,   // "
    0x50, 0x50, 0xF8, 0x50, 0xF8, 0x50, 0x50, 0x00,   // #
    0x20, 0x78, 0xA0, 0x70, 0x28, 0xF0, 0x20, 0x00,   // $
    0xC0, 0xC8, 0x10, 0x20, 0x40, 0x98, 0x18, 0x00,   // %
    0x20, 0x50, 0x50, 0x60, 0xA8, 0x90, 0x68, 0x00,   // &
    0x20, 0x20, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,   // '
    0x10, 0x20, 0x40, 0x40, 0x40, 0x20, 0x10, 0x00,   // (
    0x40, 0x20, 0x10, 0x10, 0x10, 0x20, 0x40, 0x00,   // )
    0x00, 0x20, 0xA8, 0x70, 0xA8, 0x20, 0x00, 0x00,   // *
    0x00, 0x20, 0x20, 0xF8, 0x20, 0x20, 0x00, 0x00,   // +
    0x00, 0x00, 0x00, 0x00, 0x60, 0x60, 0x20, 0x40,   // ,
    0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00,   // -
    0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x60, 0x00,   // .
    0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x00,   // /

    0x70, 0x88, 0x98, 0xA8, 0xC8, 0x88, 0x70, 0x00,   // 0
    0x20, 0x60, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00,   // 1
    0x70, 0x88, 0x08, 0x10, 0x20, 0x40, 0xF8, 0x00,   // 2
    0xF8, 0x10, 0x20, 0x10, 0x08, 0x88, 0x70, 0x00,   // 3
    0x10, 0x30, 0x50, 0x90, 0xF8, 0x10, 0x10, 0x00,   // 4
    0xF8, 0x80, 0xF0, 0x08, 0x08, 0x88, 0x70, 0x00,   // 5
    0x30, 0x40, 0x80, 0xF0, 0x88, 0x88, 0x70, 0x00,   // 6
    0xF8, 0x08, 0x10, 0x20, 0x40, 0x40, 0x40, 0x00,   // 7
    0x70, 0x88, 0x88, 0x70, 0x88, 0x88, 0x70, 0x00,   // 8
    0x70, 0x88, 0x88, 0x78, 0x08, 0x10, 0x60, 0x00,   // 9
    0x00, 0x60, 0x60, 0x00, 0x60, 0x60, 0x00, 0x00,   // :
    0x00, 0x60, 0x60, 0x00, 0x60, 0x60, 0x20, 0x40,   // ;
    0x08, 0x10, 0x20, 0x40, 0x20, 0x10, 0x08, 0x00,   // <
    0x00, 0x00, 0xF8, 0x00, 0xF8, 0x00, 0x00, 0x00,   // =
    0x80, 0x40, 0x20, 0x10, 0x20, 0x40, 0x80, 0x00,   // >
    0x70, 0x88, 0x08, 0x10, 0x20, 0x00, 0x20, 0x00,   // ?

    0x30, 0x48, 0xB8, 0xA8, 0xB8, 0x80, 0x78, 0x00,   // @
    0x70, 0x88, 0x88, 0xF8, 0x88, 0x88, 0x88, 0x00,   // A
    0xF0, 0x88, 0x88, 0xF0, 0x88, 0x88, 0xF0, 0x00,   // B
    0x70, 0x88, 0x80, 0x80, 0x80, 0x88, 0x70, 0x00,   // C
    0xE0, 0x90, 0x88, 0x88, 0x88, 0x90, 0xE0, 0x00,   // D
    0xF8, 0x80, 0x80, 0xF0, 0x80, 0x80, 0xF8, 0x00,   // E
    0xF8, 0x80, 0x80, 0xF0, 0x80, 0x80, 0x80, 0x00,   // F
    0x78, 0x80, 0x80, 0x98, 0x88, 0x88, 0x78, 0x00,   // G
    0x88, 0x88, 0x88, 0xF8, 0x88, 0x88, 0x88, 0x00,   // H
    0x70, 0x20, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00,   // I
    0x38, 0x10, 0x10, 0x10, 0x10, 0x90, 0x60, 0x00,   // J
    0x88, 0x90, 0xA0, 0xC0, 0xA0, 0x90, 0x88, 0x00,   // K
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xF8, 0x00,   // L
    0x88, 0xD8, 0xA8, 0xA8, 0x88, 0x88, 0x88, 0x00,   // M
    0x88, 0xC8, 0xA8, 0x98, 0x88, 0x88, 0x88, 0x00,   // N
    0x70, 0x88, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00,   // O

    0xF0, 0x88, 0x88, 0xF0, 0x80, 0x80, 0x80, 0x00,   // P
    0x70, 0x88, 0x88, 0x88, 0xA8, 0x90, 0x68, 0x04,   // Q
    0xF0, 0x88, 0x88, 0xF0, 0xA0, 0x90, 0x88, 0x00,   // R
    0x70, 0x88, 0x80, 0x70, 0x08, 0x88, 0x70, 0x00,   // S
    0xF8, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,   // T
    0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00,   // U
    0x88, 0x88, 0x88, 0x50, 0x50, 0x20, 0x20, 0x00,   // V
    0x88, 0x88, 0x88, 0xA8, 0xA8, 0xA8, 0x50, 0x00,   // W
    0x88, 0x88, 0x50, 0x20, 0x50, 0x88, 0x88, 0x00,   // X
    0x88, 0x88, 0x88, 0x70, 0x20, 0x20, 0x20, 0x00,   // Y
    0xF8, 0x08, 0x10, 0x20, 0x40, 0x80, 0xF8, 0x00,   // Z
    0x38, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x38,   // [
    0x00, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x00,   // back-slash
    0xE0, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xE0,   // ]
    0x20, 0x50, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00,   // ^
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x00,   // _

    0x20, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,   // `
    0x00, 0x00, 0x70, 0x08, 0x78, 0x88, 0x78, 0x00,   // a
    0x80, 0x80, 0xB0, 0xC8, 0x88, 0x88, 0xF0, 0x00,   // b
    0x00, 0x00, 0x70, 0x88, 0x80, 0x80, 0x70, 0x00,   // c
    0x08, 0x08, 0x68, 0x98, 0x88, 0x88, 0x78, 0x00,   // d
    0x00, 0x00, 0x70, 0x88, 0xF8, 0x80, 0x70, 0x00,   // e
    0x30, 0x48, 0x40, 0xF0, 0x40, 0x40, 0x40, 0x00,   // f
    0x00, 0x00, 0x78, 0x88, 0x98, 0x68, 0x08, 0x70,   // g
    0x80, 0x80, 0xB0, 0xC8, 0x88, 0x88, 0x88, 0x00,   // h
    0x20, 0x00, 0x60, 0x20, 0x20, 0x20, 0x70, 0x00,   // i
    0x10, 0x00, 0x30, 0x10, 0x10, 0x10, 0x90, 0x60,   // j
    0x80, 0x80, 0x90, 0xA0, 0xD0, 0x88, 0x88, 0x00,   // k
    0x60, 0x20, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00,   // l
    0x00, 0x00, 0xD0, 0xA8, 0xA8, 0xA8, 0x88, 0x00,   // m
    0x00, 0x00, 0xF0, 0x88, 0x88, 0x88, 0x88, 0x00,   // n
    0x00, 0x00, 0x70, 0x88, 0x88, 0x88, 0x70, 0x00,   // o

    0x00, 0x00, 0xF0, 0x88, 0x88, 0xF0, 0x80, 0x80,   // p
    0x00, 0x00, 0x78, 0x88, 0x88, 0x78, 0x08, 0x08,   // q
    0x00, 0x00, 0xB0, 0xC8, 0x80, 0x80, 0x80, 0x00,   // r
    0x00, 0x00, 0x70, 0x80, 0x70, 0x08, 0x70, 0x00,   // s
    0x40, 0x40, 0xE0, 0x40, 0x40, 0x48, 0x30, 0x00,   // t
    0x00, 0x00, 0x88, 0x88, 0x88, 0x98, 0x68, 0x00,   // u
    0x00, 0x00, 0x88, 0x88, 0x88, 0x50, 0x20, 0x00,   // v
    0x00, 0x00, 0x88, 0x88, 0xA8, 0xA8, 0x50, 0x00,   // w
    0x00, 0x00, 0x88, 0x50, 0x20, 0x50, 0x88, 0x00,   // x
    0x00, 0x00, 0x88, 0x88, 0x88, 0x78, 0x08, 0xF0,   // y
    0x00, 0x00, 0xF8, 0x10, 0x20, 0x40, 0xF8, 0x00,   // z
    0x18, 0x20, 0x20, 0x40, 0x40, 0x20, 0x20, 0x18,   // {
    0x20, 0x20, 0x20, 0x00, 0x20, 0x20, 0x20, 0x00,   // |
    0xC0, 0x20, 0x20, 0x10, 0x10, 0x20, 0x20, 0xC0,   // }
    0x00, 0xC8, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,   // ~
    0xA8, 0x50, 0xA8, 0x50, 0xA8, 0x50, 0xA8, 0x00    // del
};


/*`````````````````````````````````````````````````````````````````````````````````````````````````
*   Font definition -- Char cell: 5 x 8 pixels -- PROPORTIONAL spacing.
*   Char cell: 5 x 8 pixels (8 bytes/char); each data byte is a row of 5 pixels.
*
*   Table format: 8 bytes per character --
*          byte[0] bit 7 is descender flag, if true, shift char bitmap down 1 row;
*          byte[0] bits 2:0 specify width of character (1..5 pixels);
*          byte[1:7] (7 bytes) contain the character bitmap image
*
*   Note:  Most chars start on the top row and are 5 dots wide.
*          Upper-case letters are all 5 dots wide (same as mono font), except 'I'.
*          Digits and lower-case letters are mostly 4 dots wide, with a few exceptions,
*          e.g. '1', 'i', 'j', 'l', etc.
*          Descenders use the 8th row in the bitmap cell.
*          Special cases, e.g. 'j', '[', '{', etc, are handled by LCD_PutChar#().
*
*/
const  uint8  font_table_prop_5x8[] PROGMEM =
{
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // space
    0x03, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x40,   // !
    0x03, 0xA0, 0xA0, 0xA0, 0x00, 0x00, 0x00, 0x00,   // "
    0x05, 0x50, 0x50, 0xF8, 0x50, 0xF8, 0x50, 0x50,   // #
    0x05, 0x20, 0x78, 0xA0, 0x70, 0x28, 0xF0, 0x20,   // $
    0x05, 0xC0, 0xC8, 0x10, 0x20, 0x40, 0x98, 0x18,   // %
    0x05, 0x20, 0x50, 0x50, 0x60, 0xA8, 0x90, 0x68,   // &
    0x03, 0x40, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00,   // '
    0x04, 0x20, 0x40, 0x80, 0x80, 0x80, 0x40, 0x20,   // (
    0x04, 0x40, 0x20, 0x10, 0x10, 0x10, 0x20, 0x40,   // )
    0x05, 0x00, 0x20, 0xA8, 0x70, 0xA8, 0x20, 0x00,   // *
    0x05, 0x00, 0x20, 0x20, 0xF8, 0x20, 0x20, 0x00,   // +
    0x83, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x80,   // ,
    0x04, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00,   // -
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,   // .
    0x05, 0x00, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00,   // /

    0x04, 0x60, 0x90, 0x90, 0x90, 0x90, 0x90, 0x60,   // 0
    0x04, 0x40, 0xC0, 0x40, 0x40, 0x40, 0x40, 0xE0,   // 1
    0x04, 0x60, 0x90, 0x10, 0x20, 0x40, 0x80, 0xF0,   // 2
    0x04, 0x60, 0x90, 0x10, 0x20, 0x10, 0x90, 0x60,   // 3
    0x04, 0x10, 0x30, 0x50, 0x90, 0xF0, 0x10, 0x10,   // 4
    0x04, 0xF0, 0x80, 0xE0, 0x10, 0x10, 0x90, 0x60,   // 5
    0x04, 0x20, 0x40, 0x80, 0xE0, 0x90, 0x90, 0x60,   // 6
    0x04, 0xF0, 0x10, 0x20, 0x40, 0x80, 0x80, 0x80,   // 7
    0x04, 0x60, 0x90, 0x90, 0x60, 0x90, 0x90, 0x60,   // 8
    0x04, 0x60, 0x90, 0x90, 0x70, 0x10, 0x20, 0x40,   // 9
    0x03, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40,   // :
    0x83, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x80,   // ;
    0x04, 0x10, 0x20, 0x40, 0x80, 0x40, 0x20, 0x10,   // <
    0x05, 0x00, 0x00, 0xF8, 0x00, 0xF8, 0x00, 0x00,   // =
    0x04, 0x80, 0x40, 0x20, 0x10, 0x20, 0x40, 0x80,   // >
    0x05, 0x70, 0x88, 0x08, 0x10, 0x20, 0x00, 0x20,   // ?

    0x05, 0x30, 0x48, 0xB8, 0xA8, 0xB8, 0x80, 0x78,   // @
    0x05, 0x20, 0x50, 0x88, 0x88, 0xF8, 0x88, 0x88,   // A
    0x05, 0xF0, 0x88, 0x88, 0xF0, 0x88, 0x88, 0xF0,   // B
    0x05, 0x70, 0x88, 0x80, 0x80, 0x80, 0x88, 0x70,   // C
    0x05, 0xE0, 0x90, 0x88, 0x88, 0x88, 0x90, 0xE0,   // D
    0x05, 0xF8, 0x80, 0x80, 0xF0, 0x80, 0x80, 0xF8,   // E
    0x05, 0xF8, 0x80, 0x80, 0xF0, 0x80, 0x80, 0x80,   // F
    0x05, 0x78, 0x80, 0x80, 0x98, 0x88, 0x88, 0x78,   // G
    0x05, 0x88, 0x88, 0x88, 0xF8, 0x88, 0x88, 0x88,   // H
    0x03, 0xE0, 0x40, 0x40, 0x40, 0x40, 0x40, 0xE0,   // I
    0x04, 0x70, 0x10, 0x10, 0x10, 0x10, 0x90, 0x60,   // J
    0x05, 0x88, 0x90, 0xA0, 0xC0, 0xA0, 0x90, 0x88,   // K
    0x05, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xF8,   // L
    0x05, 0x88, 0xD8, 0xA8, 0xA8, 0x88, 0x88, 0x88,   // M
    0x05, 0x88, 0xC8, 0xA8, 0x98, 0x88, 0x88, 0x88,   // N
    0x05, 0x70, 0x88, 0x88, 0x88, 0x88, 0x88, 0x70,   // O

    0x05, 0xF0, 0x88, 0x88, 0xF0, 0x80, 0x80, 0x80,   // P
    0x05, 0x70, 0x88, 0x88, 0x88, 0xA8, 0x90, 0x68,   // Q
    0x05, 0xF0, 0x88, 0x88, 0xF0, 0xA0, 0x90, 0x88,   // R
    0x05, 0x70, 0x88, 0x80, 0x70, 0x08, 0x88, 0x70,   // S
    0x05, 0xF8, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,   // T
    0x05, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x70,   // U
    0x05, 0x88, 0x88, 0x88, 0x50, 0x50, 0x20, 0x20,   // V
    0x05, 0x88, 0x88, 0x88, 0xA8, 0xA8, 0xA8, 0x50,   // W
    0x05, 0x88, 0x88, 0x50, 0x20, 0x50, 0x88, 0x88,   // X
    0x05, 0x88, 0x88, 0x88, 0x70, 0x20, 0x20, 0x20,   // Y
    0x05, 0xF8, 0x08, 0x10, 0x20, 0x40, 0x80, 0xF8,   // Z
    0x03, 0xC0, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,   // [
    0x05, 0x00, 0x80, 0x40, 0x20, 0x10, 0x08, 0x00,   // back-slash
    0x03, 0x60, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,   // ]
    0x05, 0x20, 0x50, 0x88, 0x00, 0x00, 0x00, 0x00,   // ^
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0,   // _

    0x03, 0x80, 0x80, 0x40, 0x00, 0x00, 0x00, 0x00,   // `
    0x04, 0x00, 0x00, 0x60, 0x10, 0x70, 0x90, 0x70,   // a
    0x04, 0x80, 0x80, 0xE0, 0x90, 0x90, 0x90, 0xE0,   // b
    0x04, 0x00, 0x00, 0x70, 0x80, 0x80, 0x80, 0x70,   // c
    0x04, 0x10, 0x10, 0x70, 0x90, 0x90, 0x90, 0x70,   // d
    0x04, 0x00, 0x00, 0x60, 0x90, 0xF0, 0x80, 0x70,   // e
    0x04, 0x30, 0x40, 0x40, 0xF0, 0x40, 0x40, 0x40,   // f
    0x84, 0x00, 0x70, 0x90, 0x90, 0x70, 0x10, 0xE0,   // g
    0x04, 0x80, 0x80, 0xE0, 0x90, 0x90, 0x90, 0x90,   // h
    0x03, 0x40, 0x00, 0xC0, 0x40, 0x40, 0x40, 0x40,   // i
    0x83, 0x40, 0x00, 0xC0, 0x40, 0x40, 0x40, 0x40,   // j
    0x04, 0x80, 0x80, 0x90, 0xA0, 0xC0, 0xA0, 0x90,   // k
    0x03, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x20,   // l
    0x05, 0x00, 0x00, 0xD0, 0xA8, 0xA8, 0xA8, 0x88,   // m
    0x04, 0x00, 0x00, 0xE0, 0x90, 0x90, 0x90, 0x90,   // n
    0x04, 0x00, 0x00, 0x60, 0x90, 0x90, 0x90, 0x60,   // o

    0x84, 0x00, 0xE0, 0x90, 0x90, 0xE0, 0x80, 0x80,   // p
    0x84, 0x00, 0x70, 0x90, 0x90, 0x70, 0x10, 0x10,   // q
    0x04, 0x00, 0x00, 0xB0, 0xC0, 0x80, 0x80, 0x80,   // r
    0x04, 0x00, 0x00, 0x70, 0x80, 0x60, 0x10, 0xE0,   // s
    0x04, 0x40, 0x40, 0xE0, 0x40, 0x40, 0x40, 0x30,   // t
    0x04, 0x00, 0x00, 0x90, 0x90, 0x90, 0x90, 0x70,   // u
    0x04, 0x00, 0x00, 0x90, 0x90, 0x90, 0xA0, 0x40,   // v
    0x05, 0x00, 0x00, 0x88, 0x88, 0xA8, 0xA8, 0x50,   // w
    0x05, 0x00, 0x00, 0x88, 0x50, 0x20, 0x50, 0x88,   // x
    0x84, 0x00, 0x90, 0x90, 0x90, 0x70, 0x10, 0xE0,   // y
    0x04, 0x00, 0x00, 0xF0, 0x10, 0x20, 0x40, 0xF0,   // z
    0x04, 0x30, 0x40, 0x40, 0x80, 0x80, 0x40, 0x40,   // {
    0x03, 0x20, 0x20, 0x20, 0x00, 0x20, 0x20, 0x20,   // |
    0x04, 0xC0, 0x20, 0x20, 0x10, 0x10, 0x20, 0x20,   // }
    0x05, 0x00, 0xC8, 0x30, 0x00, 0x00, 0x00, 0x00,   // ~
    0x05, 0xA8, 0x50, 0xA8, 0x50, 0xA8, 0x50, 0xA8    // del
};


/*`````````````````````````````````````````````````````````````````````````````````````````````````
*   Font definition -- 10 x 14 pixels -- Decimal digits 0 ~ 9 only.
*   Char cell: 12 x 16 pixels (16 WORDS/char); each word is a row of 10 pixels.
*
*   The table defines symbols with a smoother appearance than that obtained by simply
*   doubling the size of the dots from font_table_mono_5x8[].
*
*   Function LCD_PutDigit_bold16p() references this table.
*/
const  uint8  font_table_digit_10x16[] PROGMEM =
{
    0x1E, 0x00, 0x3F, 0x00, 0x73, 0x80, 0x61, 0x80, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0,
    0xC0, 0xC0, 0xC0, 0xC0, 0x61, 0x80, 0x73, 0x80, 0x3F, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0C, 0x00, 0x1C, 0x00, 0x3C, 0x00, 0x3C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00,
    0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x3F, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x3F, 0x00, 0x7F, 0x80, 0xE1, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0x01, 0xC0, 0x03, 0x80, 0x07, 0x00,
    0x0E, 0x00, 0x1C, 0x00, 0x38, 0x00, 0x70, 0x00, 0xFF, 0xC0, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00,
    0x3F, 0x00, 0x7F, 0x80, 0xE1, 0xC0, 0xC0, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x0F, 0x80, 0x0F, 0x80,
    0x01, 0xC0, 0x00, 0xC0, 0xC0, 0xC0, 0xE1, 0xC0, 0x7F, 0x80, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x00, 0x07, 0x00, 0x0F, 0x00, 0x1F, 0x00, 0x3B, 0x00, 0x73, 0x00, 0xE3, 0x00, 0xC3, 0x00,
    0xFF, 0xC0, 0xFF, 0xC0, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x7F, 0x80, 0x7F, 0x80, 0x60, 0x00, 0x60, 0x00, 0x60, 0x00, 0x7F, 0x00, 0x7F, 0x80, 0x01, 0xC0,
    0x00, 0xC0, 0x00, 0xC0, 0xC0, 0xC0, 0xE1, 0xC0, 0x7F, 0x80, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x1F, 0x00, 0x3F, 0x00, 0x70, 0x00, 0xE0, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0xFF, 0x00, 0xFF, 0x80,
    0xC1, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xE1, 0xC0, 0x7F, 0x80, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xC0, 0xFF, 0xC0, 0xC0, 0xC0, 0x01, 0xC0, 0x03, 0x80, 0x07, 0x00, 0x0E, 0x00, 0x0C, 0x00,
    0x18, 0x00, 0x18, 0x00, 0x30, 0x00, 0x30, 0x00, 0x60, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x3F, 0x00, 0x7F, 0x80, 0xE1, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xE1, 0xC0, 0x7F, 0x80, 0x7F, 0x80,
    0xE1, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xE1, 0xC0, 0x7F, 0x80, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x3F, 0x00, 0x7F, 0x80, 0xE1, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xE0, 0xC0, 0x7F, 0xC0, 0x3F, 0xC0,
    0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x03, 0x80, 0x3F, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00
};


/*`````````````````````````````````````````````````````````````````````````````````````````````````
*   Font definition -- 12 x 20 pixels -- Decimal digits 0 ~ 9 only.
*   Char cell: 12 x 20 pixels (40 bytes/char);  each word is a row of 16 pixels.
*
*   The table defines symbols with a smoother appearance than that obtained by simply
*   doubling the size of the images from  font_table_prop_7x12[].
*
*   Function LCD_PutDigit_bold20p() references this table.
*/
const  uint8  font_table_digit_12x20_bold[] PROGMEM =
{
    // '0'
    0x0F, 0x00, 0x3F, 0xC0, 0x7F, 0xE0, 0x70, 0xE0, 0xE0, 0x70, 0xE0, 0x70, 0xE0, 0x70, 0xE0, 0x70,
    0xE0, 0x70, 0xE0, 0x70, 0xE0, 0x70, 0xE0, 0x70, 0xE0, 0x70, 0xE0, 0x70, 0xE0, 0x70, 0xE0, 0x70,
    0x70, 0xE0, 0x7F, 0xE0, 0x3F, 0xC0, 0x0F, 0x00,
    // '1'
    0x0E, 0x00, 0x1E, 0x00, 0x3E, 0x00, 0x7E, 0x00, 0x6E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00,
    0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00,
    0x0E, 0x00, 0x0E, 0x00, 0x7F, 0xC0, 0x7F, 0xC0,
    // '2'
    0x0F, 0x00, 0x3F, 0xC0, 0x7F, 0xE0, 0xF0, 0xF0, 0xE0, 0x70, 0xE0, 0x70, 0x00, 0x70, 0x00, 0xE0,
    0x01, 0xE0, 0x03, 0xC0, 0x07, 0x80, 0x0F, 0x00, 0x1E, 0x00, 0x3C, 0x00, 0x78, 0x00, 0x70, 0x00,
    0xE0, 0x00, 0xFF, 0xF0, 0xFF, 0xF0, 0xFF, 0xF0,
    // '3'
    0x01, 0xF0, 0x01, 0xF0, 0x01, 0xF0, 0xFF, 0xF8, 0x7F, 0xFC, 0x3F, 0xFE, 0x1F, 0xFF, 0x8F, 0xFF,
    0x07, 0xFF, 0x1F, 0xFC, 0x7F, 0xF8, 0xFF, 0xF0, 0xFF, 0xF1, 0xFF, 0xF1, 0xF8, 0xF1, 0xF8, 0xF1,
    0xF0, 0xF8, 0x01, 0xF8, 0x03, 0xFC, 0x0F, 0xFF,
    // '4'
    0x03, 0xC0, 0x07, 0xC0, 0x07, 0xC0, 0x0F, 0xC0, 0x0F, 0xC0, 0x1D, 0xC0, 0x1D, 0xC0, 0x39, 0xC0,
    0x39, 0xC0, 0x71, 0xC0, 0x71, 0xC0, 0xE1, 0xC0, 0xE1, 0xC0, 0xFF, 0xF0, 0xFF, 0xF0, 0xFF, 0xF0,
    0x01, 0xC0, 0x01, 0xC0, 0x01, 0xC0, 0x01, 0xC0,
    // '5'
    0x7F, 0xF0, 0x7F, 0xF0, 0x7F, 0xF0, 0x70, 0x00, 0x70, 0x00, 0x70, 0x00, 0x7F, 0x00, 0x7F, 0xC0,
    0x3F, 0xE0, 0x01, 0xE0, 0x00, 0xF0, 0x00, 0x70, 0x00, 0x70, 0x00, 0x70, 0xE0, 0x70, 0xE0, 0x70,
    0xF0, 0xE0, 0x7F, 0xE0, 0x3F, 0xC0, 0x0F, 0x00,
    // '6'
    0x03, 0x80, 0x0F, 0x80, 0x1F, 0x00, 0x3C, 0x00, 0x38, 0x00, 0x70, 0x00, 0x70, 0x00, 0xEF, 0x00,
    0xFF, 0xC0, 0xFF, 0xE0, 0xF0, 0xE0, 0xE0, 0x70, 0xE0, 0x70, 0xE0, 0x70, 0xE0, 0x70, 0xE0, 0x70,
    0x70, 0xE0, 0x7F, 0xE0, 0x3F, 0xC0, 0x0F, 0x00,
    // '7'
    0x00, 0xF0, 0x00, 0xF0, 0x00, 0xF0, 0xFF, 0xF1, 0xFF, 0xF8, 0xFF, 0xF8, 0x7F, 0xFC, 0x7F, 0xFC,
    0x3F, 0xFE, 0x3F, 0xFE, 0x1F, 0xFF, 0x1F, 0xFF, 0x8F, 0xFF, 0x8F, 0xFF, 0xC7, 0xFF, 0xC7, 0xFF,
    0xE3, 0xFF, 0xE3, 0xFF, 0xF1, 0xFF, 0xF1, 0xFF,
    // '8'
    0x0F, 0xFF, 0x03, 0xFC, 0x01, 0xF8, 0xF0, 0xF0, 0xF8, 0xF1, 0xF8, 0xF1, 0xF8, 0xF1, 0xF1, 0xF8,
    0x03, 0xFC, 0x07, 0xFE, 0x03, 0xFC, 0xF1, 0xF8, 0xF8, 0xF1, 0xF8, 0xF1, 0xF8, 0xF1, 0xF8, 0xF1,
    0xF0, 0xF0, 0x01, 0xF8, 0x03, 0xFC, 0x0F, 0xFF,
    // '9'
    0x0F, 0x00, 0x3F, 0xC0, 0x7F, 0xE0, 0x70, 0xE0, 0xE0, 0x70, 0xE0, 0x70, 0xE0, 0x70, 0xE0, 0x70,
    0xE0, 0x70, 0x70, 0xF0, 0x7F, 0xF0, 0x3F, 0xF0, 0x0F, 0x70, 0x00, 0xE0, 0x00, 0xE0, 0x01, 0xC0,
    0x03, 0xC0, 0x0F, 0x80, 0x1F, 0x00, 0x1C, 0x00,
};


/*`````````````````````````````````````````````````````````````````````````````````````````````````
*   Font definition -- Char cell: 7 x 12 pixels -- PROPORTIONAL spacing.
*   Char cell: 7 x 12 pixels (12 bytes/char); each data byte is a row of 7 pixels.
*
*   Table format: 11 bytes per character --
*          byte[0] bit 7 is descender flag, if true, shift char bitmap down 2 rows;
*          byte[0] bits 2:0 specify width of character (1..7 pixels);
*          byte[1:10] (10 bytes) contain the character bitmap image.
*
*   Note:  Most chars start on the top row and are 6 dots wide
*          Upper-case letters are mostly 6 dots wide and occupy the top 10 rows.
*          Lower-case letters without descenders occupy 7 rows (4th to 10th row).
*          Lower-case descenders use the 11th and 12th rows.
*/
const  uint8  font_table_prop_7x12[] PROGMEM =
{
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // SPACE
    0x04, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x20,  // !
    0x04, 0x50, 0x50, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // "
    0x06, 0x48, 0x48, 0xFC, 0x48, 0x48, 0x48, 0xFC, 0x48, 0x48, 0x00,  // #
    0x07, 0x28, 0x7E, 0xA8, 0xA8, 0x7C, 0x2A, 0x2A, 0xFC, 0x28, 0x28,  // $
    0x07, 0x00, 0x60, 0x92, 0x64, 0x08, 0x10, 0x20, 0x4C, 0x92, 0x0C,  // %
    0x07, 0x60, 0x90, 0x90, 0x90, 0x60, 0x92, 0x8C, 0x88, 0x88, 0x76,  // &
    0x04, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // '
    0x05, 0x10, 0x20, 0x20, 0x40, 0x40, 0x40, 0x40, 0x20, 0x20, 0x10,  // (
    0x05, 0x40, 0x20, 0x20, 0x10, 0x10, 0x10, 0x10, 0x20, 0x20, 0x40,  // )
    0x05, 0x00, 0x20, 0xA8, 0x70, 0xA8, 0x20, 0x00, 0x00, 0x00, 0x00,  // *
    0x05, 0x00, 0x00, 0x00, 0x20, 0x20, 0xF8, 0x20, 0x20, 0x00, 0x00,  // +
    0x83, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x60, 0x20, 0x40,  // ,
    0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00,  // -
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x60,  // .
    0x05, 0x08, 0x08, 0x10, 0x10, 0x20, 0x20, 0x40, 0x40, 0x80, 0x80,  // /

    0x06, 0x78, 0x84, 0x84, 0x8C, 0x94, 0xA4, 0xC4, 0x84, 0x84, 0x78,  // 0
    0x06, 0x20, 0x60, 0xA0, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xF8,  // 1
    0x06, 0x78, 0x84, 0x04, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0xFC,  // 2
    0x06, 0x78, 0x84, 0x04, 0x04, 0x18, 0x04, 0x04, 0x04, 0x84, 0x78,  // 3
    0x06, 0x08, 0x18, 0x28, 0x48, 0x88, 0x88, 0xFC, 0x08, 0x08, 0x08,  // 4
    0x06, 0xFC, 0x80, 0x80, 0x80, 0x78, 0x04, 0x04, 0x04, 0x84, 0x78,  // 5
    0x06, 0x78, 0x80, 0x80, 0x80, 0xF8, 0x84, 0x84, 0x84, 0x84, 0x78,  // 6
    0x06, 0xFC, 0x04, 0x08, 0x08, 0x10, 0x10, 0x20, 0x20, 0x40, 0x40,  // 7
    0x06, 0x78, 0x84, 0x84, 0x84, 0x78, 0x84, 0x84, 0x84, 0x84, 0x78,  // 8
    0x06, 0x78, 0x84, 0x84, 0x84, 0x84, 0x7C, 0x04, 0x04, 0x04, 0x78,  // 9
    0x03, 0x00, 0x00, 0x00, 0x60, 0x60, 0x00, 0x00, 0x00, 0x60, 0x60,  // :
    0x83, 0x00, 0x60, 0x60, 0x00, 0x00, 0x00, 0x60, 0x60, 0x20, 0x40,  // ;
    0x04, 0x00, 0x00, 0x10, 0x20, 0x40, 0x80, 0x40, 0x20, 0x10, 0x00,  // <
    0x05, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0xF8, 0x00, 0x00,  // =
    0x04, 0x00, 0x00, 0x80, 0x40, 0x20, 0x10, 0x20, 0x40, 0x80, 0x00,  // >
    0x06, 0x78, 0x84, 0x04, 0x04, 0x08, 0x10, 0x20, 0x20, 0x00, 0x20,  // ?

    0x07, 0x00, 0x38, 0x44, 0x92, 0xAA, 0xAA, 0x9C, 0x40, 0x3C, 0x00,  // @
    0x06, 0x78, 0x84, 0x84, 0x84, 0xFC, 0x84, 0x84, 0x84, 0x84, 0x84,  // A
    0x06, 0xF8, 0x44, 0x44, 0x44, 0x78, 0x44, 0x44, 0x44, 0x44, 0xF8,  // B
    0x06, 0x78, 0x84, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x84, 0x78,  // C
    0x06, 0xF8, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0xF8,  // D
    0x06, 0xFC, 0x80, 0x80, 0x80, 0xF8, 0x80, 0x80, 0x80, 0x80, 0xFC,  // E
    0x06, 0xFC, 0x80, 0x80, 0x80, 0xF8, 0x80, 0x80, 0x80, 0x80, 0x80,  // F
    0x06, 0x78, 0x84, 0x80, 0x80, 0x80, 0x80, 0x9C, 0x84, 0x84, 0x78,  // G
    0x06, 0x84, 0x84, 0x84, 0x84, 0xFC, 0x84, 0x84, 0x84, 0x84, 0x84,  // H
    0x04, 0x70, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x70,  // I
    0x06, 0x3C, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x88, 0x70,  // J
    0x06, 0x84, 0x88, 0x90, 0xA0, 0xC0, 0xA0, 0x90, 0x88, 0x84, 0x84,  // K
    0x06, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x84, 0xFC,  // L
    0x07, 0x82, 0xC6, 0xAA, 0xAA, 0x92, 0x92, 0x82, 0x82, 0x82, 0x82,  // M
    0x06, 0x84, 0xC4, 0xA4, 0x94, 0x8C, 0x84, 0x84, 0x84, 0x84, 0x84,  // N
    0x06, 0x78, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x78,  // O

    0x06, 0xF8, 0x84, 0x84, 0x84, 0x84, 0xF8, 0x80, 0x80, 0x80, 0x80,  // P
    0x06, 0x78, 0x84, 0x84, 0x84, 0x84, 0x84, 0x94, 0x94, 0x88, 0x74,  // Q
    0x06, 0xF8, 0x84, 0x84, 0x84, 0x84, 0xF8, 0xA0, 0x90, 0x88, 0x84,  // R
    0x06, 0x7C, 0x80, 0x80, 0x80, 0x78, 0x04, 0x04, 0x04, 0x04, 0xF8,  // S
    0x07, 0xFE, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,  // T
    0x06, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x78,  // U
    0x07, 0x82, 0x82, 0x82, 0x82, 0x44, 0x44, 0x28, 0x28, 0x10, 0x10,  // V
    0x07, 0x82, 0x82, 0x82, 0x82, 0x82, 0x92, 0x92, 0x92, 0x92, 0x6C,  // W
    0x07, 0x82, 0x82, 0x44, 0x28, 0x10, 0x10, 0x28, 0x44, 0x82, 0x82,  // X
    0x07, 0x82, 0x82, 0x82, 0x82, 0x44, 0x28, 0x10, 0x10, 0x10, 0x10,  // Y
    0x07, 0xFE, 0x02, 0x04, 0x08, 0x10, 0x10, 0x20, 0x40, 0x80, 0xFE,  // Z
    0x05, 0x70, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  // [
    0x05, 0x80, 0x80, 0x40, 0x40, 0x20, 0x20, 0x10, 0x10, 0x08, 0x08,  // back-slash
    0x05, 0x70, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,  // ]
    0x05, 0x20, 0x50, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // ^
    0x85, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x00,  // _

    0x04, 0x40, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // `
    0x06, 0x00, 0x00, 0x00, 0x78, 0x04, 0x7C, 0x84, 0x84, 0x84, 0x7C,  // a
    0x06, 0x80, 0x80, 0x80, 0xF8, 0x84, 0x84, 0x84, 0x84, 0x84, 0x78,  // b
    0x06, 0x00, 0x00, 0x00, 0x78, 0x84, 0x80, 0x80, 0x80, 0x84, 0x78,  // c
    0x06, 0x04, 0x04, 0x04, 0x7C, 0x84, 0x84, 0x84, 0x84, 0x84, 0x78,  // d
    0x06, 0x00, 0x00, 0x00, 0x78, 0x84, 0x84, 0xF8, 0x80, 0x80, 0x78,  // e
    0x05, 0x38, 0x40, 0x40, 0x40, 0xF0, 0x40, 0x40, 0x40, 0x40, 0x40,  // f
    0x86, 0x00, 0x78, 0x84, 0x84, 0x84, 0x84, 0x7C, 0x04, 0x04, 0x78,  // g
    0x06, 0x80, 0x80, 0x80, 0xF8, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84,  // h
    0x04, 0x00, 0x20, 0x00, 0x60, 0x20, 0x20, 0x20, 0x20, 0x20, 0x70,  // i
    0x84, 0x00, 0x60, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xC0,  // j
    0x06, 0x80, 0x80, 0x80, 0x88, 0x90, 0xA0, 0xE0, 0x90, 0x88, 0x84,  // k
    0x04, 0xC0, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x30,  // l
    0x07, 0x00, 0x00, 0x00, 0x6C, 0x92, 0x92, 0x92, 0x92, 0x82, 0x82,  // m
    0x06, 0x00, 0x00, 0x00, 0x78, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84,  // n
    0x06, 0x00, 0x00, 0x00, 0x78, 0x84, 0x84, 0x84, 0x84, 0x84, 0x78,  // o

    0x86, 0x00, 0x78, 0x84, 0x84, 0x84, 0x84, 0xF8, 0x80, 0x80, 0x80,  // p
    0x86, 0x00, 0x78, 0x84, 0x84, 0x84, 0x84, 0x7C, 0x04, 0x04, 0x04,  // q
    0x06, 0x00, 0x00, 0x00, 0x78, 0x84, 0x84, 0x80, 0x80, 0x80, 0x80,  // r
    0x06, 0x00, 0x00, 0x00, 0x78, 0x84, 0x80, 0x78, 0x04, 0x84, 0x78,  // s
    0x05, 0x00, 0x40, 0x40, 0xF0, 0x40, 0x40, 0x40, 0x40, 0x40, 0x38,  // t
    0x06, 0x00, 0x00, 0x00, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x78,  // u
    0x06, 0x00, 0x00, 0x00, 0x84, 0x84, 0x84, 0x84, 0x88, 0x90, 0x60,  // v
    0x07, 0x00, 0x00, 0x00, 0x82, 0x82, 0x82, 0x92, 0x92, 0x92, 0x6C,  // w
    0x07, 0x00, 0x00, 0x00, 0x82, 0x44, 0x28, 0x10, 0x28, 0x44, 0x82,  // x
    0x86, 0x00, 0x84, 0x84, 0x84, 0x84, 0x84, 0x7C, 0x04, 0x04, 0x78,  // y
    0x06, 0x00, 0x00, 0x00, 0xFC, 0x04, 0x08, 0x10, 0x20, 0x40, 0xFC,  // z
    0x06, 0x18, 0x20, 0x20, 0x20, 0x20, 0xC0, 0x20, 0x20, 0x20, 0x20,  // {
    0x05, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x20, 0x20, 0x20, 0x20,  // |
    0x06, 0xC0, 0x20, 0x20, 0x20, 0x20, 0x18, 0x20, 0x20, 0x20, 0x20,  // }
    0x07, 0x00, 0x00, 0x00, 0x60, 0x92, 0x0C, 0x00, 0x00, 0x00, 0x00,  // ~
    0x06, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00   // DEL
};


// Private data...
static  uint16 screenBuffer[64][8];  // 64 rows x 8 cols x 16 pixels = 1024 bytes

static  uint8  PixelMode;     // Pixel writing mode (see LCD_SetMode fn)
static  uint16 CursorPosX;    // screen cursor position, X-coord
static  uint16 CursorPosY;    // screen cursor position, Y-coord
static  uint8  FontProp;      // Font style (0: monospaced, 1: proportional)
static  uint8  FontSize;      // Char cell height (pixels)
static  uint8  FontWeight;    // 0 = Normal;  1 = Bold

// List of chars that are not rendered in bold typeface...
static  uint8  NotBoldCharList[] = { '"', '#', 39, ',', '.', ':', ';', '@' };


/*----------------------------------------------------------------------------------
 * Name               :  LCD_ClearScreen()
 * Function           :  Clear LCD module GDRAM and MCU screen buffer.
 *                       Position graphics cursor at upper LHS = (0, 0).
 * Input              :  --
 * Return             :  --
------------------------------------------------------------------------------------*/
void   LCD_ClearScreen(void)
{
    int     wordcount = 0;
    uint16  *pBuf = &screenBuffer[0][0];

    while (wordcount++ < 512)
    {
        *pBuf++ = 0;
    }

    LCD_ClearGDRAM();

    PixelMode = SET_PIXELS;
    FontSize = 8;
    FontWeight = 0;
    CursorPosX = 0;
    CursorPosY = 0;
}


/*----------------------------------------------------------------------------------
 * Name               :  LCD_Mode()
 * Function           :  Set global pixel write mode for all display functions,
 *                       except LCD_ClearScreen() which always clears pixels.
 *                       Default mode after LCD_ClearScreen() is SET_PIXELS.
 *
 * Input              :  mode = CLEAR_PIXELS (0), SET_PIXELS (1), or FLIP_PIXELS (2)
------------------------------------------------------------------------------------*/
void  LCD_Mode(uint8 mode)
{
    PixelMode = mode;
}


/*----------------------------------------------------------------------------------
 * Name               :  LCD_PosXY()
 * Function           :  Set graphics cursor position to (x, y) coords
 * Input              :  x, y coords
------------------------------------------------------------------------------------*/
void  LCD_PosXY(uint16 x, uint16 y)
{
    CursorPosX = x;
    CursorPosY = y;
}


/*----------------------------------------------------------------------------------
 * Name               :  LCD_GetX()
 * Function           :  Returns graphics cursor X-coord (0..127)
 * Input              :  --
 * Return             :  CursorPosX
------------------------------------------------------------------------------------*/
uint16  LCD_GetX(void)
{
    return CursorPosX;
}


/*----------------------------------------------------------------------------------
 * Name               :  LCD_GetY()
 * Function           :  Returns graphics cursor Y-coord (0..63)
 * Input              :  --
 * Return             :  CursorPosY
------------------------------------------------------------------------------------*/
uint16  LCD_GetY(void)
{
    return CursorPosY;
}


/*----------------------------------------------------------------------------------
 * Name               :  LCD_BlockFill()
 *
 * Function           :  Fills a rectangular block of the LCD with pixels,
 *                       using global writing mode (set, clear or flip),
 *                       at the graphics cursor position (x, y).
 *                       Cursor position remains unchanged.
 *
 * Input              :  w, h = width and height (pixels) of block to be filled
 *
 * Return             :  --
------------------------------------------------------------------------------------*/
void   LCD_BlockFill(uint16 w, uint16 h)
{
    uint16  rowBuffer[8];           // pixel pattern for filling whole row
    int     row, col, i;            // row and column word index for screen buffer
    int     firstCol;               // first (leftmost) column-word in a row to be modified
    int     lastCol;                // last (rightmost) column-word in a row to be modified
    int     offset;                 // shift offset (# of bits) from word boundary
    uint16  pixelWord;              // bits in column-word to be modified
    uint8   carryIn, carryOut;
    int     count;
    int     x = CursorPosX;
    int     y = CursorPosY;

    if (x > 127)  x = 0;            // prevent writing past end-of-row
    if ((x + w) > 128) w = 128 - x;

    firstCol = x / 16;
    lastCol = (x + w - 1) / 16;
    offset = x % 16;

    for (col = 0;  col < 8;  col++)  // clear row buffer
    {
        rowBuffer[col] = 0;
    }

    // Set w pixels (bits) in row buffer, aligned on word boundary of firstCol
    for ((count = w, col = firstCol);  col <= lastCol;  col++)
    {
        if (count >= 16)
        {
            rowBuffer[col] = 0xFFFF;
            count -= 16;
        }
        else  // less than 16 bits remaining
        {
            for (i = 0;  i < count;  i++)
            {
                rowBuffer[col] >>= 1;
                rowBuffer[col] |= 0x8000;
            }
            break;
        }
    }

    // Shift row to the right x bits, in effect, so that first pixel is at x-coord
    for (i = 0;  i < offset;  i++)
    {
        for ((carryIn = 0, col = firstCol);  col <= lastCol;  col++)
        {
            carryOut = (uint8) (rowBuffer[col] & 0x0001);  // carry = b0
            rowBuffer[col] >>= 1;
            if (carryIn) rowBuffer[col] |= 0x8000;  // b15 = 1
            else  rowBuffer[col] &= ~0x8000;        // b15 = 0
            carryIn = carryOut;
        }
    }

    // Update screen buffer
    for (row = y;  row < (y + h) && row < 64;  row++)
    {
        for (col = firstCol;  col <= lastCol && col < 8;  col++)
        {
            pixelWord = screenBuffer[row][col];

            if (PixelMode == SET_PIXELS) pixelWord |= rowBuffer[col];
            else if (PixelMode == CLEAR_PIXELS) pixelWord &= ~rowBuffer[col];
            else  pixelWord ^= rowBuffer[col];  // FLIP_PIXELS

            screenBuffer[row][col] = pixelWord;
        }
    }

    // Update LCD module -- write block (w x h) pixels of screen buffer at (x, y) to GDRAM
    LCD_WriteBlock((uint16 *) screenBuffer, x, y, w, h);
}


/*----------------------------------------------------------------------------------
 * Name               :  LCD_BlockClear()
 *
 * Function           :  Clears a rectangular block of the LCD at curcsor (x, y).
 *                       Cursor position and write mode remain unchanged on exit.
 *
 * Input              :  w, h = width and height (pixels) of block to be cleared
 *
------------------------------------------------------------------------------------*/
void  LCD_BlockClear(uint16 w, uint16 h)
{
    uint8 priorPixelMode = PixelMode;

    LCD_Mode(CLEAR_PIXELS);
    LCD_BlockFill(w, h);
    LCD_Mode(priorPixelMode);
}


/*----------------------------------------------------------------------------------
 * Name               :  LCD_PutImage()
 *
 * Function           :  Render bitmap image at current (x, y) using currently
 *                       selected writing mode (i.e. set, clear or flip pixels).
 *                       Cursor position is not affected.
 *
 *                       The bitmap image is assumed to be an array of bytes, ordered
 *                       as array[h][n], where n is the minimum number of bytes needed
 *                       to hold one row of pixels, i.e. w pixels, and h is the height
 *                       of the image in pixels. Bit 7 of each byte is the LHS pixel.
 *
 * Input              :  (bitmap_t *) imageData = pointer to bit-map image data
 *                       (uint16)  w = image width, h = image height, pixels
 *
 * Return             :  TRUE (1) if any pixel in the image definition is high (=1) AND
 *                       the corresponding pixel on the screen is already set (=1) before
 *                       the image is written;  otherwise return FALSE (0).
------------------------------------------------------------------------------------*/
uint8   LCD_PutImage(bitmap_t *imageData, uint16 w, uint16 h)
{
    uint16  rowBuffer[8];           // row of 128 pixels forming the image
    int     row, col, i;            // row and column word index for screen buffer
    int     firstCol;               // first (leftmost) column-word in a row to be modified
    int     lastCol;                // last (rightmost) column-word in a row to be modified
    int     offset;                 // shift offset (# of bits) from word boundary
    uint16  pixelWord;              // bits in column-word to be modified
    uint8  *pData;
    uint16  bitmask;
    uint8   carryIn, carryOut;
    int     count;
    int     imageBytesInRow;        // minimum number of bytes to hold w pixels (1 row)
    uint8   collision = 0;          // return value (0 or 1)
    uint16  x = CursorPosX;
    uint16  y = CursorPosY;

    if (x > 127)  x = 0;            // prevent writing past end-of-row
    if ((x + w) > 128) w = 128 - x;

    firstCol = x / 16;
    lastCol = (x + w - 1) / 16;
    offset = x % 16;
    imageBytesInRow = (w / 8) + ((w % 8) ? 1 : 0);

    for (row = y;  row < (y + h) && row < 64;  row++)
    {
        pData = (uint8 *)imageData + ((row - y) * imageBytesInRow);  // point to (next) row
        rowBuffer[lastCol] = 0;  // clear garbage

        // Copy row of image data to row buffer, aligned on word boundary of firstCol
        for ((count = w, col = firstCol);  col <= lastCol;  col++)
        {
            rowBuffer[col] = (uint16) *pData << 8;   // High-order (left) byte
            pData++;
            rowBuffer[col] |= (uint16) *pData;   // Low-order (right) byte, maybe garbage
            pData++;

            if (count < 16)  // less than 16 bits remaining
            {
                bitmask = 0x0000;
                for (i = 0;  i < count;  i++)
                {
                    bitmask >>= 1;
                    bitmask |= 0x8000;
                }
                rowBuffer[col] &= bitmask;  // mask off "out of bounds" pixels
                break;
            }
            else  count -= 16;  // next col.
        }

        // Shift row to the right x bits, in effect, so that first pixel is at x-coord
        for (i = 0;  i < offset;  i++)
        {
            for ((carryIn = 0, col = firstCol);  col <= lastCol;  col++)
            {
                carryOut = (uint8) (rowBuffer[col] & 0x0001);  // carry = b0
                rowBuffer[col] >>= 1;
                if (carryIn) rowBuffer[col] |= 0x8000;  // b15 = 1
                else  rowBuffer[col] &= ~0x8000;        // b15 = 0
                carryIn = carryOut;
            }
        }

        // Update 1 row in screen buffer
        for (col = firstCol;  col <= lastCol && col < 8;  col++)
        {
            pixelWord = screenBuffer[row][col];
            if (pixelWord & rowBuffer[col]) collision = 1;

            if (PixelMode == SET_PIXELS) pixelWord |= rowBuffer[col];
            else if (PixelMode == CLEAR_PIXELS) pixelWord &= ~rowBuffer[col];
            else  pixelWord ^= rowBuffer[col];  // FLIP_PIXELS

            screenBuffer[row][col] = pixelWord;
        }
    }

    // Update LCD module -- write block (w x h) pixels of screen buffer at (x, y) to GDRAM
    LCD_WriteBlock((uint16 *) screenBuffer, x, y, w, h);

    return  collision;
}


/*----------------------------------------------------------------------------------
 * Name               :  LCD_ScreenCapture()
 * Function           :  Return a pointer to the screen buffer.
 *                       The buffer is 512 words ordered as screenBuffer[rows][cols],
 *                       where rows == 64 and cols == 8. Each column is 16 pixels.
 *
 * Note               :  The screenBuffer[] array is not ordered the same as the GDRAM
 *                       memory in the ST7920 LCD controller.
 *                       (See LCD_ClearScreen() for a map of the ST7920 GDRAM buffer.)
 * Input              :  --
 * Return             :  (uint16 *) address of local screenBuffer[]
------------------------------------------------------------------------------------*/
uint16  *LCD_ScreenCapture()
{
    return  (uint16 *) &screenBuffer[0][0];
}


/*----------------------------------------------------------------------------------
 * Name               :  LCD_SetFont()
 * Function           :  Set font style for text display using functions...
 *                       LCD_PutChar(), LCD_PutText(), etc.
 *
 * Input              :  uint8  font_ID = one of the following...
 *
 *    MONO_8_NORM      Mono-spaced font;  char width is 5 pix
 *    PROP_8_NORM      Proportional font;  char width is 3..5 pix
 *    PROP_12_NORM     Proportional font;  char width is 4..7 pix
 *    PROP_12_BOLD     as above, but bold weight (width + 1)
 *    MONO_16_NORM     Mono-spaced font;  char width is 10 pix
 *    MONO_16_BOLD     as above, but bold weight (width + 1)
 *
------------------------------------------------------------------------------------*/
void   LCD_SetFont(uint8 font_ID)
{
    FontWeight = font_ID & 1;            // b0 (0: normal, 1: bold)
    FontProp = (font_ID >> 1) & 1;       // b1 (0: monospaced, 1: proportional)
    FontSize = 8 + 4 * (font_ID >> 2);   // b3:b2 (00: 8p, 01: 12p, 10: 16p)
}


/*----------------------------------------------------------------------------------
 * Name               :  LCD_GetFont()
 * Function           :  Get current font ID setting
 *
 * Input              :  --
 * Return             :  uint8  font_ID = 0 .. 11
------------------------------------------------------------------------------------*/
uint8  LCD_GetFont()
{
    uint8  size_id = (FontSize - 8) / 4;  // 0, 1, or 2

    return  (size_id << 2) + (FontProp << 1) + FontWeight;
}


/*----------------------------------------------------------------------------------
 * Name               :  LCD_PutChar()
 * Function           :  Show ASCII char at current (x, y) using selected font.
 * Input              :  (uint8) uc = ASCII char to be displayed
 * Return             :  --
------------------------------------------------------------------------------------*/
void   LCD_PutChar(char uc)
{
    if (FontSize == 16)  LCD_PutChar16(uc);
    else if (FontSize == 12)  LCD_PutChar12(uc);
    else  LCD_PutChar8(uc);
}


/*----------------------------------------------------------------------------------
 * Name               :  LCD_PutText()
 * Function           :  Show text string at (x, y) using selected font.
 *                       Stops at first non-printable char found (e.g. NUL).
 *                       Truncates text beyond the right boundary of the screen
 *                       if the string is too long to fit on the current line.
 *
 * Input              :  str = pointer to ASCII string (NUL terminated)
 * Return             :  --
------------------------------------------------------------------------------------*/
void   LCD_PutText(char *str)
{
    uint8  b;

    while ((b = *str) >= 0x20)
    {
        LCD_PutChar(b);
        str++;
    }
}


/*-------------------------------------------------------------------------------------
 * Name               :  LCD_PutDigit()
 * Function           :  Show hex/decimal digit value (1 char)
 *
 * Input              :  bDat = nybble to be converted and output
 * Return             :  --
 --------------------------------------------------------------------------------------*/
void   LCD_PutDigit(uint8 bDat)
{
    bDat &= 0x0F;
    if (bDat < 10) LCD_PutChar('0' + bDat);
    else LCD_PutChar('A' + bDat - 10);
}


/*----------------------------------------------------------------------------------------
 * Name               :  LCD_PutDigit_16p()
 *
 * Function           :  Show decimal digit value (4 bits) in 10 x 16 pix font
 *                       using a smooth "high definition" font table.
 *                       On exit, CursorPosX is advanced 12 pixels
 *
 * Input              :  digit = decimal value (0..9) to be displayed
 * Return             :  --
 */
void   LCD_PutDigit_16p(uint8 digit)
{
    uint8  bitmap[32];  // image is 16 rows x 2 columns
	char   uc = '0' + digit;

    if (uc < '0' || uc > '9') return;  // not a decimal digit - bail!

    PGM_ReadData(&font_table_digit_10x16[digit*32], bitmap, 32);
    LCD_PutImage(bitmap, 12, 16);
	CursorPosX += 12;
}


/*-------------------------------------------------------------------------------------
 * Name               :  LCD_PutDigit_20p()
 *
 * Function           :  Show decimal digit value (4 bits) in 12 x 20 pix font
 *                       using a smooth bold "high definition" font table.
 *                       On exit, CursorPosX is advanced 16 pixels
 *
 * Input              :  digit = decimal value (0..9) to be displayed
 * Return             :  --
 --------------------------------------------------------------------------------------*/
void  LCD_PutDigit_20p(uint8 digit)
{
	uint8  bitmap[40];  // image is 20 rows x 2 columns
	char   uc = '0' + digit;
	
	if (uc < '0' || uc > '9') return;  // not a decimal digit - bail!

	PGM_ReadData(&font_table_digit_12x20_bold[digit * 40], bitmap, 40);
    LCD_PutImage(bitmap, 12, 20);
    CursorPosX += 16;
}


/*---------------------------------------------------------------------------------------
 * Name               :  LCD_PutHexByte()
 * Function           :  Show hexadecimal byte value (2 chars)
 *
 * Input              :  bDat = byte data
 * Return             :  --
 ---------------------------------------------------------------------------------------*/
void   LCD_PutHexByte(uint8 bDat)
{
    LCD_PutDigit(bDat >> 4);      // MS digit
    LCD_PutDigit(bDat & 0x0F);    // LS digit
}


/*---------------------------------------------------------------------------------------
*   Name:       LCD_PutDecimalWord
*
*   Function:   Displays a 16-bit word as an unsigned decimal integer, up to 5 digits,
*               right justified in the specified field, padded with leading zeros.
*               If the value is too big to fit into the specified minimum field size,
*               the field will be expanded to accommodate the number of digits.
*
*   Args:       (uint16) uwVal = unsigned word to be converted and output
*               (byte) bFieldSize = number of character places to output (1..5)
*
*--------------------------------------------------------------------------------------*/
void  LCD_PutDecimalWord(uint16 uwVal, uint8 bFieldSize)
{
    uint8   digit[6];     // digit[0] is LSD
    uint8   place, dig;
    bool    isLeading0 = TRUE;

    if ( bFieldSize > 5 )  bFieldSize = 5;
    if ( bFieldSize < 1 )  bFieldSize = 1;

    for ( place = 0;  place < 5;  place++ )   // begin conversion with LSD
    {
        digit[place] = (uwVal % 10);
        uwVal = uwVal / 10;
    }

    for ( place = 4;  place < 5;  place-- )   // begin output with MSD
    {
        dig = digit[place];
        if (dig != 0)  isLeading0 = FALSE;           // Found non-zero digit
        if (place < bFieldSize)  LCD_PutDigit(dig);  // Inside minimum field... output always,
        else if (!isLeading0)  LCD_PutDigit(dig);    // else... output only if NOT leading zero
    }
}


/*----------------------------------------------------------------------------------------
 * Name               :  LCD_PutChar8()
 *
 * Function           :  Display character from 5 x 8 font in normal size (5 x 8 pixels)
 *                       at current cursor position.
 *                       On return, CursorPosX is advanced 6 pixels if mono-spaced,
 *                       or (width + 1) pixels if proportional.
 *
 * Input              :  uint8 uc = ASCII char code
 * Return             :  --
 *--------------------------------------------------------------------------------------*/
void  LCD_PutChar8(uint8 uc)
{
    uint8   i, j;
    uint8   bitmap[10];  // symbol image buffer (bitmap[1] is top row)
    uint8   width;       // symbol width (pixels)
    bool    descender;   // True => shift bitmap down 1 pixel in cell

    if (uc < 32) return;  // non-printable

    if (FontProp)  // proportional width font
    {
        PGM_ReadData(&font_table_prop_5x8[(uc - 32)*8], bitmap, 8);
        width = bitmap[0] & 0x0F;
        descender = bitmap[0] & 0x80;
        bitmap[8] = 0;  // clear bottom row
        
        if (descender)
        {
            for ((i = 1, j = 8);  i < 8;  i++, j--)
                bitmap[j] = bitmap[j-1];  // shift down a row
            bitmap[1] = 0;  // top row is blank
        }        
        // other special cases -- adjust bottom row
        if (uc == 'j') bitmap[8] = 0x80;
        if (uc == '[') bitmap[8] = 0xC0;
        if (uc == ']') bitmap[8] = 0x60;
        if (uc == '{') bitmap[8] = 0x30;
        if (uc == '}') bitmap[8] = 0xC0;

        LCD_PutImage(&bitmap[1], 5, 8);  // bitmap[1] is image top row
        CursorPosX += width + 1;
    }
    else  // mono-spaced font
    {
        PGM_ReadData(&font_table_mono_5x8[(uc - 32)*8], bitmap, 8);
        LCD_PutImage(bitmap, 6, 8);
        CursorPosX += 6;
    }
}


/*----------------------------------------------------------------------------------------
 * Name               :  LCD_PutChar12()
 * Function           :  Display character from 7 x 12 font in size 7 x 12 pixels
 *                       for normal weight, or 8 x 12 pix if bold weight selected.
 *                       This is a PROPORTIONALLY SPACED font (variable width).
 *                       On return, PosX is advanced (width + 2) px for normal weight,
 *                       (width + 3) for bold.
 * Input              :  uint8 uc = ASCII char code (32..127)
 * Return             :  --
 *--------------------------------------------------------------------------------------*/
void  LCD_PutChar12(uint8 uc)
{
    uint8  bitmap[16];      // bitmap[0] contains controls
    uint8  shifted;
    uint8  width;           // symbol width (pixels) in font table
    bool   descender;       // True => symbol has descender (2 pixels)
    bool   allowBold = TRUE;
    uint8  i, j = 12;

    if (uc < 32) return;  // non-printable

    for (i = 1; i < 16; i++)  { bitmap[i] = 0; }  // Clear the symbol bitmap

    // Flag symbols which should NOT be made bold
    if (uc == '@' || uc == '"' || uc == '$' || uc == '#'
    ||  uc == '.' || uc == ',' || uc == ':' || uc == ';' ) allowBold = FALSE;

    PGM_ReadData(&font_table_prop_7x12[(uc - 32) * 11], bitmap, 11);  // load bitmap

    width = bitmap[0] & 0x0F;
    descender = bitmap[0] & 0x80;

    // process descender and/or bold weight
    for ((i = 1, j = 12);  i <= 10;  i++, j--)  
    {
        shifted = bitmap[i] >> 1;
        if (FontWeight && allowBold) bitmap[i] |= shifted;  // make bold
        if (descender) bitmap[j] = bitmap[j-2];  // shift down 2 pixels
    }

    // If symbol has descender, clear top 2 rows...
    if (descender) { bitmap[1] = 0;  bitmap[2] = 0; }
    // Special case: 'j' has a dot on 2nd row
    if (uc == 'j')  bitmap[2] = bitmap[6];
    // More special cases: symbols have pixels on the 2nd bottom row = top row
    if (uc == '[' || uc == ']' || uc == '|' || uc == '{' || uc == '}' )
        bitmap[11] = bitmap[1];

    LCD_PutImage(&bitmap[1], 8, 12);  // bitmap[1] is top row
    CursorPosX += width + 2;
    if (FontWeight) CursorPosX++;  // is bold
}


/*----------------------------------------------------------------------------------------
 * Name               :  LCD_PutChar16()
 *
 * Function           :  Display character from 5 x 8 font table in double size --
 *                       10 x 16 pix for normal weight; 11 x 16 pix in bold weight.
 *
 * Note                  This font is available in monospaced format only.
 *                    :  Some special chars do not allow bold weight.
 *
 * Input              :  uint8 uc = (ext'd) ASCII char code
 * Return             :  --
 */
void   LCD_PutChar16(uint8 uc)
{
    short  exceptions = ARRAY_SIZE(NotBoldCharList);
    short  i, j, k;
    uint8  charcell[8];
    uint8  bitmap[16][2];  // image is 16 rows x 2 columns
    uint8  dots;
    uint16 bitmask8;
    uint16 bitmask16;
    uint16 pixels;
    uint16 shifted;
    uint8  allow_bold = 1;

    if (uc >= '0' && uc <= '9')  // decimal digit -- use smooth HD font
    {
        LCD_PutDigit_16p(uc - '0');
        return;
    }        

    for (i = 0; i < exceptions; i++)
    {
        if (uc == NotBoldCharList[i]) { allow_bold = 0; break; }
    }
    if (uc > 127) allow_bold = 0;  // special symbol

    PGM_ReadData(&font_table_mono_5x8[(uc - 32)*8], charcell, 8);  // load charcell

    // Double the size of the character image from charcell...
    for ((j = 0, k = 0);  j < 8;  j++)   // j is offset into charcell
    {
        bitmask8 = 0x80;
        bitmask16 = 0xC000;
        dots = charcell[j];  // a bit in charcell becomes two pixels
        pixels = 0;
        for (i = 0;  i < 8;  i++)  // build a 16-bit row of pixels
        {
            if (dots & bitmask8) pixels |= bitmask16;
            bitmask8 >>= 1;
            bitmask16 >>= 2;
        }
        // Apply bold typeface if requested...
        if (FontWeight && allow_bold)
        {
            shifted = pixels >> 1;
            pixels |= shifted;
        }
        // Construct 2 identical rows of the character bitmap
        bitmap[k][0] = HI_BYTE(pixels);    // Even numbered row of 16 pixels
        bitmap[k][1] = LO_BYTE(pixels);
        k++;
        bitmap[k][0] = HI_BYTE(pixels);    // Odd numbered row of 16 pixels
        bitmap[k][1] = LO_BYTE(pixels);
        k++;
    }

    LCD_PutImage((uint8 *) bitmap, 12, 16);
	CursorPosX += 12;
    if (FontWeight) CursorPosX++;  // is bold
}

// END-OF-FILE
